#include "stack_double.h"

#include <stdlib.h>
#include <string.h>
/* Создаем(иницилизируем) стек, в котором изначально есть только голова*/
void init_stack_double(HEAD *head) { head->point = NULL; }

/*Добавляем элемент в стек*/
void push_stack_double(double sym, HEAD *head) {
    operators *tmp;    /*Создаем временный указатель на структуру*/
    tmp = head->point; /*Присваиваем указателю значение указателя на текущий верх структуры*/
    operators *new = (operators *)malloc(sizeof(operators)); /*Выделяем память под новую структуру*/
    new->oper =
        sym; /*присваиваем значение в новую структуру(в тело структуры), значение, которое пришло в функцию*/
    new->point =
        tmp; /*Указателю в структуре присваиваем значение, которое было помещено во временный указатель*/
    head->point = new; /*в указатель передаем адрес новой структуры*/
}
/*Функция выталкивания(взятия значения из стека)*/
double pop_stack_double(HEAD *head) {
    double x; /*Обьявляем переменную, в которую потом будем записывать значение из структуры(верхней)*/
    operators *tmp = head->point; /*Вводим временный указатель на текущий верх структуры*/
    x = head->point->oper; /*Значение из тела последнего(верхнего) элемента присваиваем иксу*/
    head->point = head->point->point;
    free(tmp); /*Очищаем память из под взятого элемента*/
    return x;
}

void destroy_stack_double(HEAD *head) {
    operators *tmp = head->point; /*приваиваем временному указателю адрес указателя на стек*/
    while (head->point != NULL) { /*проделываем цикл пока указатель на стек не будет указывать на пустоту*/
        free(tmp); /*очищаем память через указатель во временной переменной*/
        head->point = head->point->point; /*Переприсваиваем указателю на стек адрес на верхний элемент стека*/
        tmp = head->point; /*снова присваиваем временной переменной значение указателя на стек*/
    }
}